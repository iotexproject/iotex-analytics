type Query {
    account: Account
    chain: Chain
    delegate(startEpoch: Int!, epochCount: Int!, delegateName: String!): Delegate
    voting(startEpoch: Int!, epochCount: Int!): Voting
    hermes(startEpoch: Int!, epochCount: Int!, rewardAddress: String!, waiverThreshold: Int!): Hermes
    xrc20: Xrc20
    action: Action
    topHolders(endEpochNumber: Int!, pagination: Pagination!):[TopHolder]!
}

type TopHolder{
    address:String!
    balance:String!
}

type Xrc20Info{
    contract:String!
    hash:String!
    timestamp:String!
    from:String!
    to:String!
    quantity:String!
}

type Xrc20 {
    byContractAddress(address:String!,numPerPage:Int!,page:Int!): Xrc20List
    byAddress(address:String!,numPerPage:Int!,page:Int!): Xrc20List
    byPage(pagination: Pagination!): Xrc20List
    xrc20Addresses(pagination: Pagination!): XRC20AddressList
}

type Account {
    activeAccounts(count: Int!): [String!]
    alias(operatorAddress: String!): Alias
    operatorAddress(aliasName: String!): OperatorAddress
}

type Action {
    byDates(startDate: Int!, endDate: Int!): ActionList
    byHash(actHash: String!): ActionDetail
    byAddress(address: String!): ActionList
    evmTransfersByAddress(address: String!): EvmTransferList
}

type Delegate {
    reward: Reward
    productivity: Productivity
    bookkeeping(percentage: Int!, includeFoundationBonus: Boolean!): Bookkeeping
    bucketInfo: BucketInfoOutput
    staking: StakingOutput
}

type StakingOutput{
    exist: Boolean!
    stakingInfo: [StakingInformation]!
}

type StakingInformation{
    epochNumber: Int!
    totalStaking: String!
    selfStaking: String!
}

type Voting {
    candidateInfo: [CandidateInfoList]!
    votingMeta: VotingMeta
    rewardSources(voterIotexAddress: String!): RewardSources
}


type CandidateInfoList {
    epochNumber: Int!
    candidates: [CandidateInfo]!
}

type CandidateInfo {
    name: String!
    address: String!
    totalWeightedVotes: String!
    selfStakingTokens: String!
    operatorAddress: String!
    rewardAddress: String!
}

type Hermes {
    exist: Boolean!
    hermesDistribution: [HermesDistribution]!
}

type HermesDistribution {
    delegateName: String!
    rewardDistribution: [RewardDistribution]!
    stakingIotexAddress: String!
    voterCount: Int!
    waiveServiceFee: Boolean!
    refund: String!
}

type VotingMeta {
    exist: Boolean!
    candidateMeta: [CandidateMeta]!
}

type RewardSources {
    exist: Boolean!
    delegateDistributions: [DelegateAmount]!
}

type ActionList {
    exist: Boolean!
    actions(pagination: Pagination): [ActionInfo]!
    count: Int!
}

type Xrc20List {
    exist: Boolean!
    xrc20(pagination: Pagination): [Xrc20Info]!
    count: Int!
}

type XRC20AddressList {
    exist: Boolean!
    addresses(pagination: Pagination): [String]!
    count: Int!
}

type ActionInfo {
    actHash: String!
    blkHash: String!
    timeStamp: Int!
    actType: String!
    sender: String!
    recipient: String!
    amount: String!
    gasFee: String!
}

type Alias {
    exist: Boolean!
    aliasName: String!
}

type OperatorAddress {
    exist: Boolean!
    operatorAddress: String!
}

type Reward {
    exist: Boolean!
    blockReward: String!
    epochReward: String!
    foundationBonus: String!
}

type Productivity {
    exist: Boolean!
    production: String!
    expectedProduction: String!
}

type BucketInfo {
    voterEthAddress: String!
    voterIotexAddress: String!
    isNative: Boolean!
    votes: String!
    weightedVotes: String!
    remainingDuration: String!
    startTime: String!
    decay: Boolean!
}

type Bookkeeping {
    exist: Boolean!
    rewardDistribution(pagination: Pagination): [RewardDistribution]!
    count: Int!
}

type BucketInfoOutput {
    exist: Boolean!
    bucketInfoList(pagination: Pagination): [BucketInfoList]!
}

type BucketInfoList {
    epochNumber: Int!
    bucketInfo: [BucketInfo]!
    count: Int!
}

type RewardDistribution {
    voterEthAddress: String!
    voterIotexAddress: String!
    amount: String!
}

type DelegateAmount {
    delegateName: String!
    amount: String!
}

type Chain {
    mostRecentEpoch: Int!
    mostRecentBlockHeight: Int!
    votingResultMeta: VotingResultMeta
    mostRecentTPS(blockWindow: Int!): Float!
    numberOfActions(pagination: EpochRange): NumberOfActions
}

type NumberOfActions{
    exist: Boolean!
    count: Int!
}

type VotingResultMeta {
    totalCandidates: Int!
    totalWeightedVotes: String!
    votedTokens: String!
}

#[TODO] combine candidateMeta with votingResultMeta
type CandidateMeta{
    epochNumber: Int!
    totalCandidates: Int!
    consensusDelegates: Int!
    totalWeightedVotes: String!
    votedTokens: String!
}

type ActionDetail{
    actionInfo: ActionInfo
    evmTransfers: [EvmTransfer]!
}

type EvmTransfer{
    from: String!
    to: String!
    quantity: String!
}

type EvmTransferDetail{
    from: String!
    to: String!
    quantity: String!
    actHash: String!
    blkHash: String!
    timeStamp: Int!
}

type EvmTransferList{
    exist: Boolean!
    evmTransfers(pagination: Pagination): [EvmTransferDetail]!
    count: Int!
}

input Pagination{
    skip: Int!
    first: Int!
}

input EpochRange{
    startEpoch: Int!
    epochCount: Int!
}